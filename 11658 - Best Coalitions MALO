

#include <iostream>
#include <vector>
#include <iomanip>
#include <cmath>
#include <stdio.h>

using namespace std;

class Fraction {
    private:
        // Calculates the greates common divisor with 
        // Euclid's algorithm
        // both arguments have to be positive
        long long gcd(long long a, long long b) {
            while (a != b) {
                if (a > b) {
                    a -= b;
                } else {
                    b -= a;
                }
            }
            return a;
        }

    public:
        long long numerator, denominator;

        Fraction() {
            numerator = 0;
            denominator = 1;
        }

        Fraction(long long n, long long d) {
            if (d==0) {
                cerr << "Denominator may not be 0." << endl;
                //exit(0);
            } else if (n == 0) {
                numerator = 0;
                denominator = 1;
            } else {
                int sign = 1;
                if (n < 0) {
                    sign *= -1;
                    n *= -1;
                }
                if (d < 0) {
                    sign *= -1;
                    d *= -1;
                }

                long long tmp = gcd(n, d);
                numerator = n/tmp*sign;
                denominator = d/tmp;
            }
        }

        operator int() {return (numerator)/denominator;}
        operator float() {return ((float)numerator)/denominator;}
        operator double() {return ((double)numerator)/denominator;}
};

Fraction operator+(const Fraction& lhs, const Fraction& rhs) {
    Fraction tmp(lhs.numerator*rhs.denominator
                +rhs.numerator*lhs.denominator,
                lhs.denominator*rhs.denominator);
    return tmp;
}

bool operator>(const Fraction& lhs, const Fraction& rhs) {
    double a = (double) lhs.numerator * (double)rhs.denominator;
    double b = (double) rhs.numerator * (double) lhs.denominator;
    return !(a < b);
}

Fraction operator+=(Fraction& lhs, const Fraction& rhs) {
    Fraction tmp(lhs.numerator*rhs.denominator
                +rhs.numerator*lhs.denominator,
                lhs.denominator*rhs.denominator);
    lhs = tmp;
    return lhs;
}

Fraction operator-(const Fraction& lhs, const Fraction& rhs) {
    Fraction tmp(lhs.numerator*rhs.denominator
                -rhs.numerator*lhs.denominator,
                lhs.denominator*rhs.denominator);
    return tmp;
}

Fraction operator-=(Fraction& lhs, const Fraction& rhs) {
    Fraction tmp(lhs.numerator*rhs.denominator
                -rhs.numerator*lhs.denominator,
                lhs.denominator*rhs.denominator);
    lhs = tmp;
    return lhs;
}

Fraction operator*(const Fraction& lhs, const Fraction& rhs) {
    Fraction tmp(lhs.numerator*rhs.numerator,
               lhs.denominator*rhs.denominator);
    return tmp;
}

Fraction operator*=(Fraction& lhs, const Fraction& rhs) {
    Fraction tmp(lhs.numerator*rhs.numerator,
               lhs.denominator*rhs.denominator);
    lhs = tmp;
    return lhs;
}

Fraction operator*(int lhs, const Fraction& rhs) {
    Fraction tmp(lhs*rhs.numerator,rhs.denominator);
    return tmp;
}

Fraction operator*(const Fraction& rhs, int lhs) {
    Fraction tmp(lhs*rhs.numerator,rhs.denominator);
    return tmp;
}

Fraction operator/(const Fraction& lhs, const Fraction& rhs) {
    Fraction tmp(lhs.numerator*rhs.denominator,
                 lhs.denominator*rhs.numerator);
    return tmp;
}

std::ostream& operator<<(std::ostream &strm, const Fraction &a) {
    if (a.denominator == 1) {
        strm << a.numerator;
    } else {
        strm << a.numerator << "/" << a.denominator;
    }
    return strm;
}

Fraction maximo(Fraction a, Fraction b){
    if(a>b) return a; else return b;
}


Fraction dp[10005][105];

vector <int> sh;
int mio;
Fraction c(int otros, int j){
    //cout << " etra" << endl;
    if(j==0){ 
        if(mio+otros>5000){
            Fraction res(100*mio, mio+otros);
            dp[otros][j] = res;
            return res;
        }else{
            Fraction res(0, 1);
            dp[otros][j] = res;
            return res;
        }
    }
    Fraction mu(-1, 1);
    if(dp[otros][j].numerator!=-1) return dp[otros][j];
    
    Fraction res = maximo(c(otros, j-1), c(otros+sh[j], j-1));
    dp[otros][j] = res;
    return res;

}

int main(int argc, char** argv) {
    freopen("in", "r", stdin);
    freopen("out", "w", stdout);

    int n, x;
    while(true){
        for(int i=0; i<10005; i++){
            for(int j=0; j<105; j++){
                Fraction mu(-1, 1);
                dp[i][j] = mu;
            }
        }
        sh.push_back(666);
        cin >> n >> x;
        if(n==0 and x==0) break;
        mio = 0;
        for(int i=1; i<=n;i++){
            double aux;
            cin >> aux;
            aux = aux * 100;
            int auxi = (int) aux;
            if(i==x){
                mio = auxi;
                continue;
            }
            sh.push_back(auxi);
        }
        cout << setprecision(2);
        cout << fixed;
        //cout << c(0, n-1) << endl;
        double res = (double) c(0, n-1);
        cout << round(res*100)/100.0 << endl;
        //cout << (ceil((c(0, n-1) * 100.0)) / 100.0) << endl;
        sh.clear();
    }
    

    return 0;
}

